package main

import (
	"bufio"
	"encoding/json"
	"flag"
	"io"
	"log"
	"os"
	"strings"
	"sync"
)

func main() {
	d := flag.String("d", "deps.csv", "dependencies csv file (generated by buildg)")
	o := flag.String("o", "pkg_repos.json", "output file containing the package repository url mapping")
	r := flag.String("r", "", "result of the previous run, if provided only new package names will be resolved")
	flag.Parse()
	depsF, err := os.Open(*d)
	if err != nil {
		log.Fatal(err)
	}

	repos := map[string]string{}
	mu := sync.Mutex{}

	if *r != "" {
		ns, err := os.Open(*r)
		if err != nil {
			log.Fatal(err)
		}
		err = json.NewDecoder(ns).Decode(&repos)
		if err != nil {
			log.Fatal(err)
		}
	}

	pkgs := make(chan string)
	wg := sync.WaitGroup{}

	for i := 0; i < 20; i++ {
		go func() {
			wg.Add(1)
			for n := range pkgs {
				rr, err := repoRootForImportDynamic(n, IgnoreMod)
				if err != nil {
					log.Printf("failed to resolve %s: %v", n, err)
					continue
				}
				r := strings.Replace(rr.Repo, "https://", "", 1)
				r = strings.Replace(r, "http://", "", 1)
				mu.Lock()
				repos[n] = r
				mu.Unlock()
			}
			wg.Done()
		}()
	}

	deps := bufio.NewReader(depsF)

	for {
		line, err := deps.ReadString('\n')
		if err == io.EOF {
			break
		}
		if err != nil {
			log.Fatal(err)
		}
		parts := strings.Split(strings.TrimRight(line, "\n"), ",")
		d := clean(parts[1])
		if strings.HasPrefix(d, "github.com") {
			continue
		}
		mu.Lock()
		_, ok := repos[d]
		mu.Unlock()
		parts = strings.Split(d, "/")
		if !ok && strings.Contains(parts[0], ".") {
			pkgs <- d
		}
	}
	close(pkgs)
	wg.Wait()
	out, err := os.Create(*o)
	if err != nil {
		log.Fatal(err)
	}
	defer out.Close()
	err = json.NewEncoder(out).Encode(repos)
	if err != nil {
		log.Fatalf("failed to encode results: %v", err)
	}

}

func clean(d string) string {
	parts := strings.Split(d, "/")
	for i := len(parts) - 1; i >= 0; i-- {
		if parts[i] == "src" || parts[i] == "vendor" || parts[i] == "_vendor" {
			return strings.Join(parts[i+1:], "/")
		}
	}
	return d
}
